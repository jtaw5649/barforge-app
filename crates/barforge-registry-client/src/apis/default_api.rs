/*
 * Barforge Registry API
 *
 * Cloudflare Workers REST API for the Barforge ecosystem.
 *
 * The version of the OpenAPI document: 0.7.1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};

/// struct for typed errors of method [`api_v1_admin_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AdminStatsGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_admin_submissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AdminSubmissionsGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_admin_submissions_id_approve_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AdminSubmissionsIdApprovePostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_admin_submissions_id_reject_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AdminSubmissionsIdRejectPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_admin_users_id_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AdminUsersIdVerifyPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_auth_sync_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AuthSyncPostError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_auth_verify_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1AuthVerifyGetError {
    Status400(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_categories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CategoriesGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsIdDeleteError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsIdGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_id_modules_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsIdModulesPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_id_modules_uuid_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsIdModulesUuidDeleteError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsIdPatchError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_collections_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1CollectionsPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_featured_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1FeaturedGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_health_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1HealthGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_index_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1IndexGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_landing_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1LandingGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_mine_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesMineGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesSearchGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_download_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidDownloadPostError {
    Status400(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_related_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidRelatedGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_reviews_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidReviewsDeleteError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_reviews_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidReviewsGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_reviews_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidReviewsPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status409(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_reviews_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidReviewsPutError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_screenshots_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidScreenshotsGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_screenshots_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidScreenshotsIdDeleteError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_screenshots_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidScreenshotsPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status413(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_star_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidStarDeleteError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_star_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidStarGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_star_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidStarPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidVersionsGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_versions_version_publish_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidVersionsVersionPublishPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status409(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_modules_uuid_versions_version_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1ModulesUuidVersionsVersionUploadPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status411(models::ProblemDetails),
    Status413(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_announcements_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsAnnouncementsPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsGetError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_id_read_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsIdReadPatchError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_mark_all_read_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsMarkAllReadPostError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_preferences_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsPreferencesGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_preferences_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsPreferencesPatchError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_stream_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsStreamGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_notifications_unread_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1NotificationsUnreadCountGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_stars_sync_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1StarsSyncPostError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_me_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersMeDeleteError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersMeGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_me_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersMePatchError {
    Status400(models::ProblemDetails),
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status429(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_me_stars_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersMeStarsGetError {
    Status401(models::ProblemDetails),
    Status403(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_username_collections_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersUsernameCollectionsGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_username_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersUsernameGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_v1_users_username_modules_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiV1UsersUsernameModulesGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`packages_uuid_version_filename_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PackagesUuidVersionFilenameGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`screenshots_uuid_filename_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScreenshotsUuidFilenameGetError {
    Status400(models::ProblemDetails),
    Status404(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`security_check_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecurityCheckGetError {
    Status400(models::ProblemDetails),
    Status500(models::ProblemDetails),
    UnknownValue(serde_json::Value),
}

pub async fn api_v1_admin_stats_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1AdminStatsGet200Response, Error<ApiV1AdminStatsGetError>> {
    let uri_str = format!("{}/api/v1/admin/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1AdminStatsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1AdminStatsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AdminStatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_admin_submissions_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1AdminSubmissionsGet200Response, Error<ApiV1AdminSubmissionsGetError>> {
    let uri_str = format!("{}/api/v1/admin/submissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1AdminSubmissionsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1AdminSubmissionsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AdminSubmissionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_admin_submissions_id_approve_post(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<String, Error<ApiV1AdminSubmissionsIdApprovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/admin/submissions/{id}/approve",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AdminSubmissionsIdApprovePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_admin_submissions_id_reject_post(
    configuration: &configuration::Configuration,
    id: i32,
    reject_request: models::RejectRequest,
) -> Result<String, Error<ApiV1AdminSubmissionsIdRejectPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_reject_request = reject_request;

    let uri_str = format!(
        "{}/api/v1/admin/submissions/{id}/reject",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_reject_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AdminSubmissionsIdRejectPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_admin_users_id_verify_post(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::ApiV1AdminUsersIdVerifyPost200Response, Error<ApiV1AdminUsersIdVerifyPostError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/admin/users/{id}/verify",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1AdminUsersIdVerifyPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1AdminUsersIdVerifyPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AdminUsersIdVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_auth_sync_post(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1AuthSyncPost200Response, Error<ApiV1AuthSyncPostError>> {
    let uri_str = format!("{}/api/v1/auth/sync", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1AuthSyncPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1AuthSyncPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AuthSyncPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_auth_verify_get(
    configuration: &configuration::Configuration,
) -> Result<models::AuthVerifyResponse, Error<ApiV1AuthVerifyGetError>> {
    let uri_str = format!("{}/api/v1/auth/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthVerifyResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthVerifyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1AuthVerifyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_categories_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1CategoriesGet200Response, Error<ApiV1CategoriesGetError>> {
    let uri_str = format!("{}/api/v1/categories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1CategoriesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1CategoriesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CategoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1CollectionsGet200Response, Error<ApiV1CollectionsGetError>> {
    let uri_str = format!("{}/api/v1/collections", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1CollectionsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1CollectionsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_id_delete(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<String, Error<ApiV1CollectionsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/collections/{id}",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_id_get(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::ApiV1CollectionsIdGet200Response, Error<ApiV1CollectionsIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/collections/{id}",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1CollectionsIdGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1CollectionsIdGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_id_modules_post(
    configuration: &configuration::Configuration,
    id: i32,
    add_module_request: models::AddModuleRequest,
) -> Result<String, Error<ApiV1CollectionsIdModulesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_add_module_request = add_module_request;

    let uri_str = format!(
        "{}/api/v1/collections/{id}/modules",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_add_module_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsIdModulesPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_id_modules_uuid_delete(
    configuration: &configuration::Configuration,
    id: i32,
    uuid: &str,
) -> Result<String, Error<ApiV1CollectionsIdModulesUuidDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/collections/{id}/modules/{uuid}",
        configuration.base_path,
        id = p_path_id,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsIdModulesUuidDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_id_patch(
    configuration: &configuration::Configuration,
    id: i32,
    update_collection_request: models::UpdateCollectionRequest,
) -> Result<String, Error<ApiV1CollectionsIdPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_update_collection_request = update_collection_request;

    let uri_str = format!(
        "{}/api/v1/collections/{id}",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_collection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsIdPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_collections_post(
    configuration: &configuration::Configuration,
    create_collection_request: models::CreateCollectionRequest,
) -> Result<models::ApiV1CollectionsPost200Response, Error<ApiV1CollectionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_collection_request = create_collection_request;

    let uri_str = format!("{}/api/v1/collections", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_collection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1CollectionsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1CollectionsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1CollectionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_featured_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1FeaturedGet200Response, Error<ApiV1FeaturedGetError>> {
    let uri_str = format!("{}/api/v1/featured", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1FeaturedGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1FeaturedGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1FeaturedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_health_get(
    configuration: &configuration::Configuration,
) -> Result<String, Error<ApiV1HealthGetError>> {
    let uri_str = format!("{}/api/v1/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1HealthGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_index_get(
    configuration: &configuration::Configuration,
) -> Result<models::RegistryIndex, Error<ApiV1IndexGetError>> {
    let uri_str = format!("{}/api/v1/index", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistryIndex`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistryIndex`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1IndexGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_landing_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1LandingGet200Response, Error<ApiV1LandingGetError>> {
    let uri_str = format!("{}/api/v1/landing", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1LandingGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1LandingGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1LandingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_get(
    configuration: &configuration::Configuration,
    q: Option<&str>,
    category: Option<&str>,
    sort: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::ApiV1ModulesGet200Response, Error<ApiV1ModulesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_q = q;
    let p_query_category = category;
    let p_query_sort = sort;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/v1/modules", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category {
        req_builder = req_builder.query(&[("category", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_mine_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1ModulesGet200Response, Error<ApiV1ModulesMineGetError>> {
    let uri_str = format!("{}/api/v1/modules/mine", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesMineGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_post(
    configuration: &configuration::Configuration,
    create_module_request: models::CreateModuleRequest,
) -> Result<models::ApiV1ModulesPost200Response, Error<ApiV1ModulesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_module_request = create_module_request;

    let uri_str = format!("{}/api/v1/modules", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_module_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_search_get(
    configuration: &configuration::Configuration,
    q: Option<&str>,
    category: Option<&str>,
    sort: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::ApiV1ModulesGet200Response, Error<ApiV1ModulesSearchGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_q = q;
    let p_query_category = category;
    let p_query_sort = sort;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/v1/modules/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category {
        req_builder = req_builder.query(&[("category", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Legacy endpoint. When DOWNLOADS_MODE=logpush, download counts are derived from package log ingestion and this endpoint is a no-op.
pub async fn api_v1_modules_uuid_download_post(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<String, Error<ApiV1ModulesUuidDownloadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/download",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidDownloadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_get(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::ApiV1ModulesUuidGet200Response, Error<ApiV1ModulesUuidGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_related_get(
    configuration: &configuration::Configuration,
    uuid: &str,
    limit: Option<i32>,
) -> Result<models::ApiV1ModulesGet200Response, Error<ApiV1ModulesUuidRelatedGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_query_limit = limit;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/related",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidRelatedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_reviews_delete(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<String, Error<ApiV1ModulesUuidReviewsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/reviews",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidReviewsDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_reviews_get(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::ApiV1ModulesUuidReviewsGet200Response, Error<ApiV1ModulesUuidReviewsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/reviews",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidReviewsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidReviewsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidReviewsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_reviews_post(
    configuration: &configuration::Configuration,
    uuid: &str,
    create_review_request: models::CreateReviewRequest,
) -> Result<String, Error<ApiV1ModulesUuidReviewsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_create_review_request = create_review_request;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/reviews",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_review_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidReviewsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_reviews_put(
    configuration: &configuration::Configuration,
    uuid: &str,
    create_review_request: models::CreateReviewRequest,
) -> Result<String, Error<ApiV1ModulesUuidReviewsPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_create_review_request = create_review_request;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/reviews",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_create_review_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidReviewsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_screenshots_get(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<
    models::ApiV1ModulesUuidScreenshotsGet200Response,
    Error<ApiV1ModulesUuidScreenshotsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/screenshots",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidScreenshotsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidScreenshotsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidScreenshotsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_screenshots_id_delete(
    configuration: &configuration::Configuration,
    uuid: &str,
    id: i32,
) -> Result<models::ScreenshotDeleteResponse, Error<ApiV1ModulesUuidScreenshotsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/screenshots/{id}",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid),
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidScreenshotsIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_screenshots_post(
    configuration: &configuration::Configuration,
    uuid: &str,
    body: std::path::PathBuf,
    alt_text: Option<&str>,
) -> Result<models::ScreenshotUploadResponse, Error<ApiV1ModulesUuidScreenshotsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_body = body;
    let p_query_alt_text = alt_text;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/screenshots",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_alt_text {
        req_builder = req_builder.query(&[("alt_text", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let file = TokioFile::open(p_body_body).await?;
    let stream = FramedRead::new(file, BytesCodec::new());
    req_builder = req_builder.body(reqwest::Body::wrap_stream(stream));

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotUploadResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotUploadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidScreenshotsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_star_delete(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<String, Error<ApiV1ModulesUuidStarDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/star",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidStarDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_star_get(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::ApiV1ModulesUuidStarGet200Response, Error<ApiV1ModulesUuidStarGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/star",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidStarGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidStarGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidStarGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_star_post(
    configuration: &configuration::Configuration,
    uuid: &str,
    star_request: Option<models::StarRequest>,
) -> Result<String, Error<ApiV1ModulesUuidStarPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_star_request = star_request;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/star",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_star_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidStarPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_versions_get(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::ApiV1ModulesUuidVersionsGet200Response, Error<ApiV1ModulesUuidVersionsGetError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/versions",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_versions_version_publish_post(
    configuration: &configuration::Configuration,
    uuid: &str,
    version: &str,
    publish_request: models::PublishRequest,
) -> Result<
    models::ApiV1ModulesUuidVersionsVersionPublishPost200Response,
    Error<ApiV1ModulesUuidVersionsVersionPublishPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_path_version = version;
    let p_body_publish_request = publish_request;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/versions/{version}/publish",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid),
        version = crate::apis::urlencode(p_path_version)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_publish_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsVersionPublishPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsVersionPublishPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidVersionsVersionPublishPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_modules_uuid_versions_version_upload_post(
    configuration: &configuration::Configuration,
    uuid: &str,
    version: &str,
    content_length: i32,
    body: std::path::PathBuf,
) -> Result<
    models::ApiV1ModulesUuidVersionsVersionUploadPost200Response,
    Error<ApiV1ModulesUuidVersionsVersionUploadPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_path_version = version;
    let p_header_content_length = content_length;
    let p_body_body = body;

    let uri_str = format!(
        "{}/api/v1/modules/{uuid}/versions/{version}/upload",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid),
        version = crate::apis::urlencode(p_path_version)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Content-Length", p_header_content_length.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let file = TokioFile::open(p_body_body).await?;
    let stream = FramedRead::new(file, BytesCodec::new());
    req_builder = req_builder.body(reqwest::Body::wrap_stream(stream));

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsVersionUploadPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesUuidVersionsVersionUploadPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1ModulesUuidVersionsVersionUploadPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_announcements_post(
    configuration: &configuration::Configuration,
    announcement_request: models::AnnouncementRequest,
) -> Result<
    models::ApiV1NotificationsAnnouncementsPost200Response,
    Error<ApiV1NotificationsAnnouncementsPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_announcement_request = announcement_request;

    let uri_str = format!(
        "{}/api/v1/notifications/announcements",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsAnnouncementsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsAnnouncementsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsAnnouncementsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_get(
    configuration: &configuration::Configuration,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::ApiV1NotificationsGet200Response, Error<ApiV1NotificationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/v1/notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_id_read_patch(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<
    models::ApiV1NotificationsIdReadPatch200Response,
    Error<ApiV1NotificationsIdReadPatchError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/api/v1/notifications/{id}/read",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsIdReadPatch200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsIdReadPatch200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsIdReadPatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_mark_all_read_post(
    configuration: &configuration::Configuration,
) -> Result<
    models::ApiV1NotificationsMarkAllReadPost200Response,
    Error<ApiV1NotificationsMarkAllReadPostError>,
> {
    let uri_str = format!(
        "{}/api/v1/notifications/mark-all-read",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsMarkAllReadPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsMarkAllReadPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsMarkAllReadPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_preferences_get(
    configuration: &configuration::Configuration,
) -> Result<
    models::ApiV1NotificationsPreferencesGet200Response,
    Error<ApiV1NotificationsPreferencesGetError>,
> {
    let uri_str = format!(
        "{}/api/v1/notifications/preferences",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsPreferencesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsPreferencesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsPreferencesGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_preferences_patch(
    configuration: &configuration::Configuration,
    notification_preferences: models::NotificationPreferences,
) -> Result<
    models::ApiV1NotificationsPreferencesGet200Response,
    Error<ApiV1NotificationsPreferencesPatchError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_notification_preferences = notification_preferences;

    let uri_str = format!(
        "{}/api/v1/notifications/preferences",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_preferences);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsPreferencesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsPreferencesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsPreferencesPatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_stream_get(
    configuration: &configuration::Configuration,
) -> Result<String, Error<ApiV1NotificationsStreamGetError>> {
    let uri_str = format!("{}/api/v1/notifications/stream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsStreamGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_notifications_unread_count_get(
    configuration: &configuration::Configuration,
) -> Result<
    models::ApiV1NotificationsUnreadCountGet200Response,
    Error<ApiV1NotificationsUnreadCountGetError>,
> {
    let uri_str = format!(
        "{}/api/v1/notifications/unread-count",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1NotificationsUnreadCountGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1NotificationsUnreadCountGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1NotificationsUnreadCountGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_stars_sync_post(
    configuration: &configuration::Configuration,
    sync_stars_request: models::SyncStarsRequest,
) -> Result<models::ApiV1StarsSyncPost200Response, Error<ApiV1StarsSyncPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_sync_stars_request = sync_stars_request;

    let uri_str = format!("{}/api/v1/stars/sync", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_sync_stars_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1StarsSyncPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1StarsSyncPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1StarsSyncPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_me_delete(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1UsersMeDelete200Response, Error<ApiV1UsersMeDeleteError>> {
    let uri_str = format!("{}/api/v1/users/me", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1UsersMeDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1UsersMeDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersMeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_me_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1UsersMeGet200Response, Error<ApiV1UsersMeGetError>> {
    let uri_str = format!("{}/api/v1/users/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1UsersMeGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1UsersMeGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_me_patch(
    configuration: &configuration::Configuration,
    update_profile_request: models::UpdateProfileRequest,
) -> Result<String, Error<ApiV1UsersMePatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_update_profile_request = update_profile_request;

    let uri_str = format!("{}/api/v1/users/me", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_update_profile_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Ok(content),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersMePatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_me_stars_get(
    configuration: &configuration::Configuration,
) -> Result<models::ApiV1UsersMeStarsGet200Response, Error<ApiV1UsersMeStarsGetError>> {
    let uri_str = format!("{}/api/v1/users/me/stars", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1UsersMeStarsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1UsersMeStarsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersMeStarsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_username_collections_get(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::ApiV1CollectionsGet200Response, Error<ApiV1UsersUsernameCollectionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_username = username;

    let uri_str = format!(
        "{}/api/v1/users/{username}/collections",
        configuration.base_path,
        username = crate::apis::urlencode(p_path_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1CollectionsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1CollectionsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersUsernameCollectionsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_username_get(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::ApiV1UsersMeGet200Response, Error<ApiV1UsersUsernameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_username = username;

    let uri_str = format!(
        "{}/api/v1/users/{username}",
        configuration.base_path,
        username = crate::apis::urlencode(p_path_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1UsersMeGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1UsersMeGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersUsernameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn api_v1_users_username_modules_get(
    configuration: &configuration::Configuration,
    username: &str,
) -> Result<models::ApiV1ModulesGet200Response, Error<ApiV1UsersUsernameModulesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_username = username;

    let uri_str = format!(
        "{}/api/v1/users/{username}/modules",
        configuration.base_path,
        username = crate::apis::urlencode(p_path_username)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV1ModulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiV1UsersUsernameModulesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn packages_uuid_version_filename_get(
    configuration: &configuration::Configuration,
    uuid: &str,
    version: &str,
    filename: &str,
) -> Result<reqwest::Response, Error<PackagesUuidVersionFilenameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_path_version = version;
    let p_path_filename = filename;

    let uri_str = format!(
        "{}/packages/{uuid}/{version}/{filename}",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid),
        version = crate::apis::urlencode(p_path_version),
        filename = crate::apis::urlencode(p_path_filename)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<PackagesUuidVersionFilenameGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn screenshots_uuid_filename_get(
    configuration: &configuration::Configuration,
    uuid: &str,
    filename: &str,
) -> Result<reqwest::Response, Error<ScreenshotsUuidFilenameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_path_filename = filename;

    let uri_str = format!(
        "{}/screenshots/{uuid}/{filename}",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid),
        filename = crate::apis::urlencode(p_path_filename)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<ScreenshotsUuidFilenameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn security_check_get(
    configuration: &configuration::Configuration,
    uuid: &str,
    version: &str,
) -> Result<models::SecurityCheckGet200Response, Error<SecurityCheckGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_uuid = uuid;
    let p_query_version = version;

    let uri_str = format!("{}/security/check", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("uuid", &p_query_uuid.to_string())]);
    req_builder = req_builder.query(&[("version", &p_query_version.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecurityCheckGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecurityCheckGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecurityCheckGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
